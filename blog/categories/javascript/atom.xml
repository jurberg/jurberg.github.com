<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | The UrBlog]]></title>
  <link href="http://jurberg.github.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://jurberg.github.com/"/>
  <updated>2013-02-26T21:41:34-06:00</updated>
  <id>http://jurberg.github.com/</id>
  <author>
    <name><![CDATA[John Urberg]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A simple JavaScript module]]></title>
    <link href="http://jurberg.github.com/blog/2013/02/26/simple-define-js/"/>
    <updated>2013-02-26T21:00:00-06:00</updated>
    <id>http://jurberg.github.com/blog/2013/02/26/simple-define-js</id>
    <content type="html"><![CDATA[<p>When developing JavaScript, I like to break my code into modules and define what modules the depend on.  <a href="http://requirejs.org/">Require.JS</a> is a great tool for this, but it also means bringing in module loading.  I'm on a project using <a href="http://grails.org/">Grails</a> that has a moderate amount of JavaScript.  Grails provides a resource plugin that handles bundling of resources.  I would still like to use the Require.JS style of defining modules and their dependencies while still loading scripts the normal way so Grails is happy.</p>


<p>I ended up creating <a href="https://github.com/jurberg/define.js">define.js</a>.  This libary provides a simple 'define' and 'require' method.  The 'define' uses the global object to hold the modules so they are also available in html handlers.  Using the global object as the module list also allows us to treat third party libraries such as jQuery as dependencies.</p>


<p>The following example creates a module that depends on the domain.person module, jQuery and the window object.  Since we are using the global to store modules, we can treat jQuery and window just like any other dependency we have defined.</p>


<script src="https://gist.github.com/jurberg/5044824.js"></script>


<p>Using the global object to hold modules also allows us to access them in html</p>


<script src="https://gist.github.com/jurberg/5044843.js"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[An introduction to Node.js]]></title>
    <link href="http://jurberg.github.com/blog/2011/08/11/introduction-to-node/"/>
    <updated>2011-08-11T19:00:00-05:00</updated>
    <id>http://jurberg.github.com/blog/2011/08/11/introduction-to-node</id>
    <content type="html"><![CDATA[<p>Node.js is an evented I/O server built on Google's V8 JavaScript engine. Node provides a simple way to build highly scalable server applications. This article will provide an introduction to Node along with installation details and a first server. <a href="http://www.objectpartners.com/2011/08/23/an-introduction-to-node-js/">more...</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scaling with Single Threading]]></title>
    <link href="http://jurberg.github.com/blog/2011/08/09/scaling-with-single-threading/"/>
    <updated>2011-08-09T19:00:00-05:00</updated>
    <id>http://jurberg.github.com/blog/2011/08/09/scaling-with-single-threading</id>
    <content type="html"><![CDATA[<p>The free lunch is over. To speed up applications we are told we must write multithreaded programs and avoid mutable state. Functional programming can help with it's immutable state. There's also Erlang with the Actor model or Clojure with it's software transactional memory. One other option to consider is single threading your code. Following are a few examples where single threading was used to scale applications.</p>

<p><a href="http://www.objectpartners.com/2011/08/09/scaling-with-single-threading/">more...</a></p>
]]></content>
  </entry>
  
</feed>
